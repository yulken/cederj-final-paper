\begin{capitulo}{Conceitos} \label{cap:concepts}


\paragrafo{Este capítulo tem como objetivo apresentar os conceitos de \emph{Clean Architecture}, \emph{Design Patterns} e \emph{SOLID}.}

\begin{secao}{Clean Architecture} \label{sec:carch}

\paragrafo{Antes de descrevermos do que se trata a arquitetura limpa, é importante descrever o próprio conceito de arquitetura de software.}

\begin{subsecao}{A arquitetura de Software} \label{subsec:arquitetura}
  \paragrafo{A Arquitetura de software de um sistema se refere às decisões de design relacionadas a estrutura e comportamento geral do sistema. A arquitetura ajuda stakeholders a entenderem e analisarem como o sistema irá alcançar características essenciais como manuseabilidade, disponibilidade e segurança \cite{soft_arch}.}
  \paragrafo{Ao desenvolver continuamente sem se preocupar com essas decisões, as características acima se tornam mais difíceis de serem alcançadas, ocasionando problemas no longo prazo que decorrem justamente da ausência dessas características. Um software com pouca manuseabilidade irá requerir mais esforço e mais mão de obra para se dar manutenção, enquanto um sistema com pouca segurança terá um comportamento inconsistente e alta incidência de bugs. A combinação dos dois fatores anteriores acarretam em custos desnecessários e tempo perdido testando e retestando fluxos já desenvolvidos previamente.}
  \paragrafo{Dito isso, de acordo com Robert C. Martin, o objetivo de uma boa arquitetura de software "...é minimizar os recursos humanos necessários para construir e manter um determinado sistema". \cite[p.5]{clean_arch}}

\end{subsecao}

\begin{subsecao}{Arquitetura Limpa} \label{subsec:carch}
  \paragrafo{Robert C. Martin menciona que toda arquitetura limpa tem a Separação de Preocupações (\emph{Separation of Concerns}). Esta consiste em segregar todo o código em módulos de acordo com suas preocupações, ou seja, quais classes ou outros detalhes da aplicação este teria acesso. O conceito da arquitetura limpa reune esses módulos em diferentes níveis de acordo com sua proximidade das regras de negócio de uma empresa, sendo o software de nível mais baixo relacionado apenas a ferramentas externas, e o mais alto, relacionado diretamente às regras de negócio.}
  \paragrafo{O importante sobre essa divisão em níveis é garantir que mudanças nas camadas inferiores não afetem as camadas superiores. Enquanto uma mudança a nível de regra de negócio pode interferir na forma que um dado é manipulado ou é exibido, o contrário não deveria ser verdade. Esse seria o conceito de Regra da Dependência, que consiste em garantir que as dependências do código partam apenas do nível inferior para o superior.}
  \paragrafo{Esses níveis podem ser representados como circulos concêntricos, de forma que as camadas de nível mais alto do código estejam mais ao centro do círculo, tal como a Figura \ref{fig:carch}.}
  \begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{CleanArchitecture}
    \caption{A arquitetura limpa}
    \label{fig:carch}
  \end{figure}
  \paragrafo{A seguir, será detalhado do que cada nível se trata nesse modelo, e, a fim de elucidar cada camada, usaremos como exemplo um sistema de gerenciamento de usuários.}

  \paragrafo{Regras de Negócio de Empresa (\emph{Enterprise Business Rules}), ou as Entidades, são objetos com suas próprias funções ou estruturas de dados que possam ser utilizadas por várias aplicações diferentes numa mesma empresa. No contexto desse trabalho e na maioria das aplicações web, as entidades serão as tabelas do banco de dados, devido a sua grande tendência de reutilização em diferentes partes de um mesmo sistema. No exemplo proposto, a entidade seria uma tabela de usuários com os atributos do mesmo, como o nome, endereço, login e senha.}
  \paragrafo{Regras de Negócio da Aplicação (\emph{Application Business Rules}), ou os Casos de Uso, são todos os fluxos especificos de uma aplicação. Essas regras de negócio utilizam-se manipulam as Entidades a fim de processar o que lhes for pedido. No exemplo proposto, os casos de uso seriam os algoritmos de cadastro, autenticação, consulta, atualização, remoção e outras tarefas referentes à tabela previamente apresentada.}
  \paragrafo{Os Adaptadores de Interface (\emph{Interface Adapters}) tem como propósito converter os dados entre os níveis vizinhos de uma forma que seja conveniente para todos os envolvidos. Um exemplo de adaptador no sistema pode ser uma classe responsável por tratar as requisições recebidas pelos frameworks a fim de executar os casos de uso para gerenciar os usuários.}
  \paragrafo{Por fim, os Frameworks e Drivers são geralmente, no contexto de desenvolvimento web, as ferramentas usadas para acesso a banco de dados e web. Por serem ferramentas já prontas, geralmente só é desenvolvido nessa camada a comunicação com os níveis mais internos.}
  \paragrafo{Em resumo, um sistema que separa suas preocupações e que segue a Regra da Dependência tendem ter uma arquitetura limpa, com módulos de lógica de negócios testáveis, independentes de frameworks, UI, banco de dados ou qualquer agência externa.}
  \end{subsecao}
  \end{secao}

\begin{secao}{Design Patterns} \label{sec:patterns}

  \paragrafo{Como alguns princípios vistos na seção de Clean Architecture, os Design Patterns tem como principal função garantir a reusabilidade do código com baixo acoplamento. De fato, a proposta principal do livro está em ser um catálogo de soluções para problemas de sistemas orientados a objetos.}
  \paragrafo{No total, são 23 padrões de projetos diferentes, subdividos em 3 tipos: Padrões de Criação, Padrões Comportamentais e Padrões Estruturais:}
  
  \paragrafo{Padrões de Criação}
  \begin{lista}
   \itemlista{Abstract Factory}
   \itemlista{Builder}
   \itemlista{Factory Method}
   \itemlista{Prototype}
   \itemlista{Singleton}
  \end{lista}

  \paragrafo{Padrões Estruturais}
  \begin{lista}
    \itemlista{Adapter}
    \itemlista{Bridge}
    \itemlista{Composite}
    \itemlista{Decorator}
    \itemlista{Facade}
    \itemlista{Flyweight}
    \itemlista{Proxy}
  \end{lista}
  
  \paragrafo{Padrões Comportamentais}
  \begin{lista}
    \itemlista{Chain of Responsiblity}
    \itemlista{Command}
    \itemlista{Interpreter}
    \itemlista{Iterator}
    \itemlista{Mediator}
    \itemlista{Memento}
    \itemlista{Observer}
    \itemlista{State}
    \itemlista{Strategy}
    \itemlista{Template Method}
    \itemlista{Visitor}
  \end{lista}
  
  \paragrafo{Não faz parte da proposta desse trabalho usar cada um dos padrões supracitados. A proposta está em identificar as oportunidades de aplicação durante as etapas de desenvolvimento. Como o sistema, até o atual momento, não está pronto, será necessário revisitar esse capítulo posteriormente listando e explicando cada padrão usado na aplicação web.}
\end{secao}

\begin{secao}{SOLID} \label{sec:solid}
  \paragrafo{Os princípios SOLID, em resumo, se tratam de regras de organização de funções e estruturas de dados em agrupamentos. O principal objetivo de sua aplicação está em criar software que seja de fácil entendimento, manutenção e reaproveitamento.}
  \paragrafo{Também proposto por Robert C. Martin, SOLID é um acrônimo para outras siglas:}
  \begin{lista}
   \itemlista{Princípio da Responsabilidade Única (\emph{Single Responsiblity Principle})}
   \itemlista{Princípio do Aberto/Fechado (\emph{Open-Closed Principle})}
   \itemlista{Princípio de Substituição de Liskov (\emph{Liskov Substitution Principle})}
   \itemlista{Princípio da Segregação de Interface (\emph{Interface Segregation Principle})}
   \itemlista{Princípio da Inversão de Dependência (\emph{Dependency Inversion Principle})}
    \vspace{0.6cm}
  \end{lista}
  \paragrafo{Definindo os príncipios, bem resumidamente, teríamos:}
  \begin{lista}
   \itemlista{\acs{SRP} - Cada módulo de software deve ser estruturado de forma que haja uma, e apenas uma, razão para mudar.}
   \itemlista{\acs{OCP} - Para que o software seja fácil de mudar, deve ser projetado para garantir que o mesmo está aberto à adição, mas fechado para alteração.}
   \itemlista{\acs{LSP} - Criando um sistema a partir de partes trocáveis entre si, estas partes devem firmar um contrato que permita que uma seja substituída pela outra.}
   \itemlista{\acs{ISP} - Deve-se evitar que o software dependa de métodos que não usa.}
   \itemlista{\acs{DIP} - Código de nível mais alto (Próximo às regras de negócio) não deve depender de código de nível mais baixo (detalhes de implementação, \emph{frameworks}, banco de dados).}
    \vspace{0.6cm}
  \end{lista}
  \paragrafo{Os exemplos da implementação desses princípios serão fornecidos posteriormente neste mesmo trabalho, no Capítulo 4.}
\end{secao}

\end{capitulo}