
\paragrafo{No fluxo descrito na seção anterior já é possível encontrar alguns
conceitos SOLID sendo implementados na aplicação web. Porém, será necessário ver
outros fluxos para obter exemplos de implementação que sigam todos os
princípios.}

\begin{subsecao}{Implementação e Benefícios do \acs{SRP}}\label{subsec:dev_srp}

\paragrafo{O Princípio da Responsabilidade Única (\acs{SRP}) está sendo seguido
na classe ShowGameService. Isso ocorre pois a classe tem apenas um propósito,
que é a exibição dos detalhes do jogo. Sendo assim, a mesma tem um escopo mais
restrito em razões para se necessitar de alteração, por exemplo, adicionar
validações, passar a buscar os jogos pelo nome em vez do id, entre outros.}

\vspace{5mm}
\input{latex/codes/solid/ShowGameService.ts.tex}
\vspace{5mm}
  
\paragrafo{Uma forma fácil de imaginar a classe acima ferindo este princípio
seria se a mesma além de exibir jogos, também criasse ou atualizasse os mesdemos.
Com isso, a manutenção dessa classe pode ser mais difícil de se realizar do que
a da primeira:}

\vspace{5mm}
\input{latex/codes/solid/SRPViolation.tex}
\vspace{5mm}

\paragrafo{Ao absorver muitas responsabilidades, a classe GameService passa a
englobar diversos comportamentos e, com isso, passa a exigir mais esforço para
se manusear.}

\paragrafo{Desta forma, o leitor pode se questionar porque a classe
 GamesController não viola o \acs{SRP}, visto que a mesma realiza todas essas
 operações. Isso não se caracteriza como uma violação pois a responsabilidade da
 classe é apenas comunicar as chamadas recebidas via HTTP para a aplicação. O
 \emph{Controller} desconhece os fluxos de exibição, criação ou atualização, mas
 conhece as classes que contêm esses fluxos.}
\end{subsecao}
\begin{subsecao}{Implementação e Benefícios do \acs{OCP}}\label{subsec:dev_ocp}

\paragrafo{Para exemplificar o Princípio Aberto Fechado (\acs{OCP}), usaremos o
fluxo responsável pela reinvidicação de cartões pré-pagos. Para usar esse
serviço, o usuário insere o código de cartão um cartão pré-pago e resgata jogos
ou dinheiro para a compra de jogos na loja.} 

\paragrafo{Porém, ao cadastrar esses códigos no sistema, a validação para esses
dois tipos de items a ser reinvidicados é diferente. Os cartões de dinheiro
devem resgatar somente os valores de R\$30, R\$50 ou R\$100. Para validar um
jogo, somente é necessário que este exista.}

\paragrafo{Com os requisitos acima, um desenvolvedor pode pensar em criar a 
seguinte classe:}

\vspace{5mm}
\input{latex/codes/solid/CreateCodeService.ts.tex}
\vspace{5mm}

\paragrafo{Embora atenda a demanda, essa estratégia fere o \acs{OCP}. Note que,
se em algum momento no futuro for necessário reinvidicar um terceiro item,
teremos que adicionar mais um if ao método principal dessa classe, o que deixará
o código ainda mais acoplado.} 

\paragrafo{Para ilustrar isso, suponhamos que será necessário reinvidicar
códigos que resgatem Pacotes de Expansão para jogos já cadastrados em nossa
plataforma. Essa funcionalidade extrapola o escopo desse trabalho, mas sua
implementação nessa classe seria algo como o exemplo a seguir:}

\vspace{5mm}
\input{latex/codes/solid/OCPviolationExample.tex}
\vspace{5mm}

\paragrafo{Para não ferir este princípio, basta estendermos a funcionalidade de
uma classe base e realizar as validações nas classes herdeiras. A seguir temos
os passos para realizar esse procedimento:} 

\paragrafo{Primeiramente, definimos uma classe abstrata que concentrará os
métodos que serão realizados pelas classes filhas desta. Como os fluxos de
cadastro de códigos para jogo e dinheiro virtual passam por processos diferentes
de validação e cadastro, este serão métodos abstratos desta classe.}

\vspace{5mm}
\input{latex/codes/solid/AbstractCodeTemplate.ts.tex}
\vspace{5mm}

\paragrafo{Em seguida, estendemos, a partir da classe abstrata, uma classe para
cada comportamento diferente. Sendo assim, uma classe para validar e registrar
jogos e outra para dinheiro virtual.}

\vspace{5mm}
\input{latex/codes/solid/CreateGameCodeService.ts.tex}
\vspace{5mm}

\vspace{5mm}
\input{latex/codes/solid/CreateCashCodeService.ts.tex}
\vspace{5mm}

\end{subsecao}
\begin{subsecao}{Implementação e Benefícios do \acs{LSP}}\label{subsec:dev_lsp}

\paragrafo{Um exemplo muito recorrente do próximo princípio, isto é, o
Princípio da Substituição de Liskov (\acs{LSP}), está no funcionamento 
das classes \emph{Repository} da aplicação.} 

\paragrafo{Tomando por exemplo o \emph{Repository} de Usuários,
temos a interface IUsersRepository e suas implementações UsersRepository e
FakeUsersRepository.}

\vspace{5mm}
\input{latex/codes/solid/IUsersRepository.ts.tex}
\vspace{5mm}

\vspace{5mm}
\input{latex/codes/solid/UsersRepository.ts.tex}
\vspace{5mm}

\vspace{5mm}
\input{latex/codes/solid/FakeUsersRepository.ts.tex}
\vspace{5mm}

\paragrafo{Podemos dizer que o \acs{LSP} é respeitado na relação entre esses
três módulos pois qualquer uma das implementações da interface IUsersRepository
é válida de ser importada no módulo CreateUserService, visto que nenhuma delas
quebraria a aplicação.} 

\vspace{5mm}
\input{latex/codes/solid/CreateUserService.ts.tex}
\vspace{5mm}

\paragrafo{O mesmo não seria verdade se, por exemplo, a
interface não especificasse um método requerido na criação de usuário. Na hora
que esse método fosse invocado no Caso de Uso, haveria um erro na execução da
aplicação.}

\notaeditor{Nota: Completar a seção com o ISP e DIP}

\end{subsecao}